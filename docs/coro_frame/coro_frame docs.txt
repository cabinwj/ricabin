1. 协程是什么？
在程序执行的过程中，允许用户根据需要随意控制（切换）执行的代码段。
其实这个代码段可以理解为用户定义的不同应用函数。

2. 那么，要实现这样一个具有切换功能的函数。具体是怎样实现？
1). 首先，需要在这个用户定义的函数Call()的首尾添加一些简单代码。即把该用户函数Call()封装成一个协程函数。
以便顺利切入用户定义的函数Call()，该函数执行完成后，设置成僵死状态，并切回主协程。
void coroutine::proc(void* ctx)
{
    coroutine* coro = (coroutine*)ctx;
    coro->Call();
    coro->m_is_zombie_ = true;
    coro_scheduler::push_coro(coro);
    coro_scheduler::yield();
}

其中：
a. proc()是协程执行函数； 
b. Call()封装了用户自定义的应用函数。
    virtual void Call()
    {
       func(); // 用户spawn的时候传入的 
    }

2). 其次，需要一个记录和保存这个协程函数的执行“现场”。这样才能实现协程的切换。
coro_context* coro;        // 这个变量记录保存所有协程对象对应的协程函数的执行“现场”，以便实现协程的切换

3). 最后，需要一些变量用来记录（标记）调度协程时的一些状态信息。
int m_reference_count_;    // 关联引用计数，确保协程安全销毁
bool m_is_zombie_;         // 协程是否僵死：协程函数运行结束后不会自行销毁，只做僵死标记，后由主协程将其销毁
bool m_is_scheduling_;     // 协程是否已在任务队列：遍历任务队列，调度协程
size_t m_stack_size_;      // 协程函数执行栈空间大小

4). 还是要说明下函数coro_create() 的作用，这个不好理解 
汇编ASM我看不懂  看了下线程实现。这个函数的意义是 切入 协程执行函数
coroutine::proc(void* ctx) 后， coro_context* coro和此执行函数现场对应。
再切回主协程。  相当于找了个入口 以后方便切换回来。

5). 其他的变量，函数都很好理解。就不多写了。 
总之，我理解的  ASM 的协程实现其实就是 由 一个 函数  函数上下文（现场）
 和一些协程标记成员组成的类（一个普普通通的类）。  程序就是  单一的函数调用原理 。
 只是这个函数 有 现场 保存，所以可以在主协程和一般的协程之间切换 （其实就是根据现场 继续执行协程函数）。 

再来讨论下协程的调度：
协程的调度总是 一般的协程 和 主协程 之间的依次切换 。
主协程的任务是管理一般协程的调度（当然调度的依据的网络层的数据包和定时器的触发）。
很好理解 ，类似于操作系统和各个运行在操作系统上的进程之间的关系。看起来很完美 很安全，
现在还看不出来什么问题 。  

 

主协程的调度 原理图 看出：
主协程 每次循环 基本做3件事情 完成所有协程调度：
    1.  coro_scheduler::schedule();
    2.  timer_manager::scan_timer();
    3.  net_manager.pop_event(); 
    (还有些异常处理 这里没有写出 。)








